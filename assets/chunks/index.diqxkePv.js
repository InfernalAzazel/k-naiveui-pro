import{isOn as U,isRenderableAttrValue as k,isSVGTag as j,propsToAttrMap as q,isBooleanAttr as z,includeBooleanAttr as I,isSSRSafeAttrName as K,escapeHtml as p,normalizeClass as F,isString as h,normalizeStyle as J,stringifyStyle as Q,createVNode as E,isArray as m,ssrContextKey as $,toDisplayString as X,isObject as Y,ssrUtils as S,looseEqual as B,looseIndexOf as Z,isPromise as g,NOOP as A,isFunction as ee,Fragment as te,Static as re,Comment as ne,escapeHtmlComment as se,Text as oe,isVoidTag as ie,mergeProps as le,createApp as v,initDirectivesForSSR as fe,makeMap as ae,getGlobalThis as ce}from"./framework.C-mL38yw.js";/**
* @vue/server-renderer v3.5.8
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const ue=ae(",key,ref,innerHTML,textContent,ref_key,ref_for");function de(e,t){let n="";for(const r in e){if(ue(r)||U(r)||t==="textarea"&&r==="value")continue;const s=e[r];r==="class"?n+=` class="${ye(s)}"`:r==="style"?n+=` style="${ge(s)}"`:r==="className"?n+=` class="${String(s)}"`:n+=pe(r,s,t)}return n}function pe(e,t,n){if(!k(t))return"";const r=n&&(n.indexOf("-")>0||j(n))?e:q[e]||e.toLowerCase();return z(r)?I(t)?` ${r}`:"":K(r)?t===""?` ${r}`:` ${r}="${p(t)}"`:(console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${r}`),"")}function he(e,t){return k(t)?` ${e}="${p(t)}"`:""}function ye(e){return p(F(e))}function ge(e){if(!e)return"";if(h(e))return p(e);const t=J(e);return p(Q(t))}function We(e,t=null,n=null,r=null,s){return w(E(e,t,n),r,s)}const{ensureValidVNode:me}=S;function Me(e,t,n,r,s,o,i){s("<!--[-->"),Se(e,t,n,r,s,o,i),s("<!--]-->")}function Se(e,t,n,r,s,o,i,l){const c=e[t];if(c){const a=[],f=c(n,d=>{a.push(d)},o,i?" "+i:"");if(m(f)){const d=me(f);d?b(s,d,o,i):r&&r()}else{let d=!0;if(l)d=!1;else for(let y=0;y<a.length;y++)if(!we(a[y])){d=!1;break}if(d)r&&r();else{let y=0,C=a.length;l&&a[0]==="<!--[-->"&&a[C-1]==="<!--]-->"&&(y++,C--);for(let N=y;N<C;N++)s(a[N])}}}else r&&r()}const _e=/^<!--[\s\S]*-->$/,Te=/<!--[^]*?-->/gm;function we(e){return typeof e!="string"||!_e.test(e)?!1:e.length<=8?!0:!e.replace(Te,"").trim()}function be(e,t,n,r,s){e("<!--teleport start-->");const o=s.appContext.provides[$],i=o.__teleportBuffers||(o.__teleportBuffers={}),l=i[n]||(i[n]=[]),c=l.length;let a;if(r)t(e),a="<!--teleport start anchor--><!--teleport anchor-->";else{const{getBuffer:u,push:f}=M();f("<!--teleport start anchor-->"),t(f),f("<!--teleport anchor-->"),a=u()}l.splice(c,0,a),e("<!--teleport end-->")}function He(e){return p(X(e))}{const e=ce(),t=(n,r)=>{let s;return(s=e[n])||(s=e[n]=[]),s.push(r),o=>{s.length>1?s.forEach(i=>i(o)):s[0](o)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}function Oe(e,t){if(m(e)||h(e))for(let n=0,r=e.length;n<r;n++)t(e[n],n);else if(typeof e=="number")for(let n=0;n<e;n++)t(n+1,n);else if(Y(e))if(e[Symbol.iterator]){const n=Array.from(e);for(let r=0,s=n.length;r<s;r++)t(n[r],r)}else{const n=Object.keys(e);for(let r=0,s=n.length;r<s;r++){const o=n[r];t(e[o],o,r)}}}async function Le(e,{default:t}){t?t():e("<!---->")}function De(e,t,n,r,s={}){return typeof t!="function"&&t.getSSRProps?t.getSSRProps({dir:t,instance:S.getComponentPublicInstance(e.$),value:n,oldValue:void 0,arg:r,modifiers:s},null)||{}:{}}const Ge=B;function W(e,t){return Z(e,t)>-1}function Ue(e,t,n){switch(e){case"radio":return B(t,n)?" checked":"";case"checkbox":return(m(t)?W(t,n):t)?" checked":"";default:return he("value",t)}}function je(e={},t){const{type:n,value:r}=e;switch(n){case"radio":return B(t,r)?{checked:!0}:null;case"checkbox":return(m(t)?W(t,r):t)?{checked:!0}:null;default:return{value:t}}}function Re(e,t){throw new Error("On-the-fly template compilation is not supported in the ESM build of @vue/server-renderer. All templates must be pre-compiled into render functions.")}const{createComponentInstance:Ce,setCurrentRenderingInstance:V,setupComponent:Ne,renderComponentRoot:x,normalizeVNode:Ae,pushWarningContext:qe,popWarningContext:ze}=S;function M(){let e=!1;const t=[];return{getBuffer(){return t},push(n){const r=h(n);if(e&&r){t[t.length-1]+=n;return}t.push(n),e=r,(g(n)||m(n)&&n.hasAsync)&&(t.hasAsync=!0)}}}function w(e,t=null,n){const r=e.component=Ce(e,t,null),s=Ne(r,!0),o=g(s);let i=r.sp;return o||i?Promise.resolve(s).then(()=>{if(o&&(i=r.sp),i)return Promise.all(i.map(c=>c.call(r.proxy)))}).catch(A).then(()=>P(r,n)):P(r,n)}function P(e,t){const n=e.type,{getBuffer:r,push:s}=M();if(ee(n)){let o=x(e);if(!n.props)for(const i in e.attrs)i.startsWith("data-v-")&&((o.props||(o.props={}))[i]="");T(s,e.subTree=o,e,t)}else{(!e.render||e.render===A)&&!e.ssrRender&&!n.ssrRender&&h(n.template)&&(n.ssrRender=Re(n.template));const o=e.ssrRender||n.ssrRender;if(o){let i=e.inheritAttrs!==!1?e.attrs:void 0,l=!1,c=e;for(;;){const u=c.vnode.scopeId;u&&(l||(i={...i},l=!0),i[u]="");const f=c.parent;if(f&&f.subTree&&f.subTree===c.vnode)c=f;else break}if(t){l||(i={...i});const u=t.trim().split(" ");for(let f=0;f<u.length;f++)i[u[f]]=""}const a=V(e);try{o(e.proxy,s,e,i,e.props,e.setupState,e.data,e.ctx)}finally{V(a)}}else e.render&&e.render!==A?T(s,e.subTree=x(e),e,t):(n.name||n.__file,s("<!---->"))}return r()}function T(e,t,n,r){const{type:s,shapeFlag:o,children:i,dirs:l,props:c}=t;switch(l&&(t.props=$e(t,c,l)),s){case oe:e(p(i));break;case ne:e(i?`<!--${se(i)}-->`:"<!---->");break;case re:e(i);break;case te:t.slotScopeIds&&(r=(r?r+" ":"")+t.slotScopeIds.join(" ")),e("<!--[-->"),b(e,i,n,r),e("<!--]-->");break;default:o&1?Ee(e,t,n,r):o&6?e(w(t,n,r)):o&64?Be(e,t,n,r):o&128&&T(e,t.ssContent,n,r)}}function b(e,t,n,r){for(let s=0;s<t.length;s++)T(e,Ae(t[s]),n,r)}function Ee(e,t,n,r){const s=t.type;let{props:o,children:i,shapeFlag:l,scopeId:c}=t,a=`<${s}`;o&&(a+=de(o,s)),c&&(a+=` ${c}`);let u=n,f=t;for(;u&&f===u.subTree;)f=u.vnode,f.scopeId&&(a+=` ${f.scopeId}`),u=u.parent;if(r&&(a+=` ${r}`),e(a+">"),!ie(s)){let d=!1;o&&(o.innerHTML?(d=!0,e(o.innerHTML)):o.textContent?(d=!0,e(p(o.textContent))):s==="textarea"&&o.value&&(d=!0,e(p(o.value)))),d||(l&8?e(p(i)):l&16&&b(e,i,n,r)),e(`</${s}>`)}}function $e(e,t,n){const r=[];for(let s=0;s<n.length;s++){const o=n[s],{dir:{getSSRProps:i}}=o;if(i){const l=i(o,e);l&&r.push(l)}}return le(t||{},...r)}function Be(e,t,n,r){const s=t.props&&t.props.to,o=t.props&&t.props.disabled;if(!s)return[];if(!h(s))return[];be(e,i=>{b(i,t.children,n,r)},s,o||o==="",n)}const{isVNode:Ve}=S;function _(e,t,n){if(!e.hasAsync)return t+O(e);let r=t;for(let s=n;s<e.length;s+=1){const o=e[s];if(h(o)){r+=o;continue}if(g(o))return o.then(l=>(e[s]=l,_(e,r,s)));const i=_(o,r,0);if(g(i))return i.then(l=>(e[s]=l,_(e,"",s)));r=i}return r}function H(e){return _(e,"",0)}function O(e){let t="";for(let n=0;n<e.length;n++){let r=e[n];h(r)?t+=r:t+=O(r)}return t}async function xe(e,t={}){if(Ve(e))return xe(v({render:()=>e}),t);const n=E(e._component,e._props);n.appContext=e._context,e.provide($,t);const r=await w(n),s=await H(r);if(await L(t),t.__watcherHandles)for(const o of t.__watcherHandles)o();return s}async function L(e){if(e.__teleportBuffers){e.teleports=e.teleports||{};for(const t in e.__teleportBuffers)e.teleports[t]=await H(await Promise.all([e.__teleportBuffers[t]]))}}const{isVNode:Pe}=S;async function D(e,t){if(e.hasAsync)for(let n=0;n<e.length;n++){let r=e[n];g(r)&&(r=await r),h(r)?t.push(r):await D(r,t)}else G(e,t)}function G(e,t){for(let n=0;n<e.length;n++){let r=e[n];h(r)?t.push(r):G(r,t)}}function R(e,t,n){if(Pe(e))return R(v({render:()=>e}),t,n);const r=E(e._component,e._props);return r.appContext=e._context,e.provide($,t),Promise.resolve(w(r)).then(s=>D(s,n)).then(()=>L(t)).then(()=>{if(t.__watcherHandles)for(const s of t.__watcherHandles)s()}).then(()=>n.push(null)).catch(s=>{n.destroy(s)}),n}function Ie(e,t={}){return console.warn("[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead."),ke(e,t)}function ke(e,t={}){throw new Error("ESM build of renderToStream() does not support renderToNodeStream(). Use pipeToNodeWritable() with an existing Node.js Writable stream instance instead.")}function Ke(e,t={},n){R(e,t,{push(r){r!=null?n.write(r):n.end()},destroy(r){n.destroy(r)}})}function Fe(e,t={}){if(typeof ReadableStream!="function")throw new Error("ReadableStream constructor is not available in the global scope. If the target environment does support web streams, consider using pipeToWebWritable() with an existing WritableStream instance instead.");const n=new TextEncoder;let r=!1;return new ReadableStream({start(s){R(e,t,{push(o){r||(o!=null?s.enqueue(n.encode(o)):s.close())},destroy(o){s.error(o)}})},cancel(){r=!0}})}function Je(e,t={},n){const r=n.getWriter(),s=new TextEncoder;let o=!1;try{o=g(r.ready)}catch{}R(e,t,{async push(i){return o&&await r.ready,i!=null?r.write(s.encode(i)):r.close()},destroy(i){console.log(i),r.close()}})}fe();export{Ke as pipeToNodeWritable,Je as pipeToWebWritable,ke as renderToNodeStream,R as renderToSimpleStream,Ie as renderToStream,xe as renderToString,Fe as renderToWebStream,De as ssrGetDirectiveProps,je as ssrGetDynamicModelProps,I as ssrIncludeBooleanAttr,He as ssrInterpolate,W as ssrLooseContain,Ge as ssrLooseEqual,he as ssrRenderAttr,de as ssrRenderAttrs,ye as ssrRenderClass,We as ssrRenderComponent,pe as ssrRenderDynamicAttr,Ue as ssrRenderDynamicModel,Oe as ssrRenderList,Me as ssrRenderSlot,Se as ssrRenderSlotInner,ge as ssrRenderStyle,Le as ssrRenderSuspense,be as ssrRenderTeleport,T as ssrRenderVNode};
